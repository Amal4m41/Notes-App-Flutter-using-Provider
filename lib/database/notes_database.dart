import 'package:flutter/material.dart';
import 'package:notes_app_provider/models/note.dart';
import 'package:notes_app_provider/utils/constants.dart' as constants;
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

//For persisting notes.
class NotesDatabase {
  static final NotesDatabase instance = NotesDatabase._init();
  static Database? _database;

  NotesDatabase._init();

  Future<Database?> get database async {
    //if _database is null then initialize it
    _database ??= await _initDB("notes.db");

    return _database;
  }

  Future<Database> _initDB(String fileName) async {
    final String dbPath =
        await getDatabasesPath(); //Get the default databases location

    final path = join(dbPath, fileName);

    return await openDatabase(path, version: 1, onCreate: _createDB);
  }

  //Creating the database table(this function is only called when the database 'notes.db' doesn't exist.
  Future _createDB(Database db, int version) async {
    const String idType = 'INTEGER PRIMARY KEY AUTOINCREMENT';
    const String textType = 'TEXT NOT NULL';
    const String boolType = 'BOOLEAN NOT NULL';
    const String integerType = 'INTEGER NOT NULL';

    String sql = ''' 
    CREATE TABLE ${constants.kNotesTableName} (
      ${NoteFields.id} $idType,
      ${NoteFields.title} $textType,
      ${NoteFields.description} $textType,
      ${NoteFields.colorIndex} $integerType,
      ${NoteFields.createdTime} $textType
    )''';
    await db.execute(sql);
  }

  Future<Note> insertNote(Note note) async {
    final db = await instance.database;

    //Returns the id that is generated by the db.
    final recordId = await db!.insert(constants.kNotesTableName, note.toJson());
    return note.copy(
        id: recordId); //return the note object with the generated id.
  }

  Future<Note> readNote(int id) async {
    final db = await instance.database;

    final List<Map<String, Object?>> listOfMaps = await db!.query(
      constants.kNotesTableName,
      columns: NoteFields.columns,
      where: "${NoteFields.id} = ?",
      whereArgs: [id], //prevents sql injection attacks.
    );

    if (listOfMaps.isNotEmpty) {
      return Note.fromJson(json: listOfMaps.first);
    } else {
      throw Exception("Record with ID: $id doesn't exist");
    }
  }

  Future<List<Note>> readAll() async {
    final db = await instance.database;

    final String orderBy = '${NoteFields.createdTime} ASC';

    final List<Map<String, Object?>> listOfMaps =
        await db!.query(constants.kNotesTableName, orderBy: orderBy);

    return listOfMaps.map((json) => Note.fromJson(json: json)).toList();
  }

  Future<int> update(Note note) async {
    final db = await instance.database;

    final recordId = await db!.update(
      constants.kNotesTableName,
      note.toJson(),
      where: "${NoteFields.id} = ?",
      whereArgs: [note.id],
    );

    return recordId;
  }

  Future<void> delete(int id) async {
    final db = await instance.database;

    db!.delete(constants.kNotesTableName,
        where: "${NoteFields.id} = ?", whereArgs: [id]);
  }

  Future close() async {
    final db = await instance.database;

    db!.close();
  }
}
